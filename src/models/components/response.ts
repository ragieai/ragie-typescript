/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import { ClosedEnum } from "../../types/enums.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";
import {
  CodeInterpreterOutput,
  CodeInterpreterOutput$inboundSchema,
  CodeInterpreterOutput$Outbound,
  CodeInterpreterOutput$outboundSchema,
} from "./codeinterpreteroutput.js";
import {
  FileSearchOutput,
  FileSearchOutput$inboundSchema,
  FileSearchOutput$Outbound,
  FileSearchOutput$outboundSchema,
} from "./filesearchoutput.js";
import {
  FinalAnswer,
  FinalAnswer$inboundSchema,
  FinalAnswer$Outbound,
  FinalAnswer$outboundSchema,
} from "./finalanswer.js";
import {
  RagieApiSchemaResponseUsage,
  RagieApiSchemaResponseUsage$inboundSchema,
  RagieApiSchemaResponseUsage$Outbound,
  RagieApiSchemaResponseUsage$outboundSchema,
} from "./ragieapischemaresponseusage.js";
import {
  Reasoning,
  Reasoning$inboundSchema,
  Reasoning$Outbound,
  Reasoning$outboundSchema,
} from "./reasoning.js";
import {
  ReasoningOutput,
  ReasoningOutput$inboundSchema,
  ReasoningOutput$Outbound,
  ReasoningOutput$outboundSchema,
} from "./reasoningoutput.js";
import {
  ResponseOutputMessage,
  ResponseOutputMessage$inboundSchema,
  ResponseOutputMessage$Outbound,
  ResponseOutputMessage$outboundSchema,
} from "./responseoutputmessage.js";
import {
  Tool,
  Tool$inboundSchema,
  Tool$Outbound,
  Tool$outboundSchema,
} from "./tool.js";

export const Status = {
  Completed: "completed",
  Failed: "failed",
  InProgress: "in_progress",
  Cancelled: "cancelled",
} as const;
export type Status = ClosedEnum<typeof Status>;

export type Output =
  | ReasoningOutput
  | CodeInterpreterOutput
  | FileSearchOutput
  | ResponseOutputMessage;

export type ResponseT = {
  id: string;
  object?: "response" | undefined;
  createdAt: number;
  status: Status;
  error?: string | null | undefined;
  incompleteDetails?: any | null | undefined;
  instructions?: string | null | undefined;
  maxOutputTokens?: any | null | undefined;
  model?: "deep-search" | undefined;
  output: Array<
    | ReasoningOutput
    | CodeInterpreterOutput
    | FileSearchOutput
    | ResponseOutputMessage
  >;
  outputParsed?: FinalAnswer | null | undefined;
  tools: Array<Tool>;
  reasoning: Reasoning;
  parallelToolCalls?: boolean | undefined;
  store?: boolean | undefined;
  temperature?: number | undefined;
  previousResponseId?: string | null | undefined;
  toolChoice?: "auto" | undefined;
  topP?: number | undefined;
  truncation?: "disabled" | undefined;
  usage: RagieApiSchemaResponseUsage;
  user?: any | null | undefined;
  metadata?: { [k: string]: any } | undefined;
};

/** @internal */
export const Status$inboundSchema: z.ZodNativeEnum<typeof Status> = z
  .nativeEnum(Status);

/** @internal */
export const Status$outboundSchema: z.ZodNativeEnum<typeof Status> =
  Status$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Status$ {
  /** @deprecated use `Status$inboundSchema` instead. */
  export const inboundSchema = Status$inboundSchema;
  /** @deprecated use `Status$outboundSchema` instead. */
  export const outboundSchema = Status$outboundSchema;
}

/** @internal */
export const Output$inboundSchema: z.ZodType<Output, z.ZodTypeDef, unknown> = z
  .union([
    ReasoningOutput$inboundSchema,
    CodeInterpreterOutput$inboundSchema,
    FileSearchOutput$inboundSchema,
    ResponseOutputMessage$inboundSchema,
  ]);

/** @internal */
export type Output$Outbound =
  | ReasoningOutput$Outbound
  | CodeInterpreterOutput$Outbound
  | FileSearchOutput$Outbound
  | ResponseOutputMessage$Outbound;

/** @internal */
export const Output$outboundSchema: z.ZodType<
  Output$Outbound,
  z.ZodTypeDef,
  Output
> = z.union([
  ReasoningOutput$outboundSchema,
  CodeInterpreterOutput$outboundSchema,
  FileSearchOutput$outboundSchema,
  ResponseOutputMessage$outboundSchema,
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Output$ {
  /** @deprecated use `Output$inboundSchema` instead. */
  export const inboundSchema = Output$inboundSchema;
  /** @deprecated use `Output$outboundSchema` instead. */
  export const outboundSchema = Output$outboundSchema;
  /** @deprecated use `Output$Outbound` instead. */
  export type Outbound = Output$Outbound;
}

export function outputToJSON(output: Output): string {
  return JSON.stringify(Output$outboundSchema.parse(output));
}

export function outputFromJSON(
  jsonString: string,
): SafeParseResult<Output, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Output$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Output' from JSON`,
  );
}

/** @internal */
export const ResponseT$inboundSchema: z.ZodType<
  ResponseT,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  object: z.literal("response").default("response"),
  created_at: z.number().int(),
  status: Status$inboundSchema,
  error: z.nullable(z.string()).optional(),
  incomplete_details: z.nullable(z.any()).optional(),
  instructions: z.nullable(z.string()).optional(),
  max_output_tokens: z.nullable(z.any()).optional(),
  model: z.literal("deep-search").default("deep-search"),
  output: z.array(
    z.union([
      ReasoningOutput$inboundSchema,
      CodeInterpreterOutput$inboundSchema,
      FileSearchOutput$inboundSchema,
      ResponseOutputMessage$inboundSchema,
    ]),
  ),
  output_parsed: z.nullable(FinalAnswer$inboundSchema).optional(),
  tools: z.array(Tool$inboundSchema),
  reasoning: Reasoning$inboundSchema,
  parallel_tool_calls: z.boolean().default(false),
  store: z.boolean().default(false),
  temperature: z.number().default(1),
  previous_response_id: z.nullable(z.string()).optional(),
  tool_choice: z.literal("auto").default("auto"),
  top_p: z.number().default(1),
  truncation: z.literal("disabled").default("disabled"),
  usage: RagieApiSchemaResponseUsage$inboundSchema,
  user: z.nullable(z.any()).optional(),
  metadata: z.record(z.any()).optional(),
}).transform((v) => {
  return remap$(v, {
    "created_at": "createdAt",
    "incomplete_details": "incompleteDetails",
    "max_output_tokens": "maxOutputTokens",
    "output_parsed": "outputParsed",
    "parallel_tool_calls": "parallelToolCalls",
    "previous_response_id": "previousResponseId",
    "tool_choice": "toolChoice",
    "top_p": "topP",
  });
});

/** @internal */
export type ResponseT$Outbound = {
  id: string;
  object: "response";
  created_at: number;
  status: string;
  error?: string | null | undefined;
  incomplete_details?: any | null | undefined;
  instructions?: string | null | undefined;
  max_output_tokens?: any | null | undefined;
  model: "deep-search";
  output: Array<
    | ReasoningOutput$Outbound
    | CodeInterpreterOutput$Outbound
    | FileSearchOutput$Outbound
    | ResponseOutputMessage$Outbound
  >;
  output_parsed?: FinalAnswer$Outbound | null | undefined;
  tools: Array<Tool$Outbound>;
  reasoning: Reasoning$Outbound;
  parallel_tool_calls: boolean;
  store: boolean;
  temperature: number;
  previous_response_id?: string | null | undefined;
  tool_choice: "auto";
  top_p: number;
  truncation: "disabled";
  usage: RagieApiSchemaResponseUsage$Outbound;
  user?: any | null | undefined;
  metadata?: { [k: string]: any } | undefined;
};

/** @internal */
export const ResponseT$outboundSchema: z.ZodType<
  ResponseT$Outbound,
  z.ZodTypeDef,
  ResponseT
> = z.object({
  id: z.string(),
  object: z.literal("response").default("response" as const),
  createdAt: z.number().int(),
  status: Status$outboundSchema,
  error: z.nullable(z.string()).optional(),
  incompleteDetails: z.nullable(z.any()).optional(),
  instructions: z.nullable(z.string()).optional(),
  maxOutputTokens: z.nullable(z.any()).optional(),
  model: z.literal("deep-search").default("deep-search" as const),
  output: z.array(
    z.union([
      ReasoningOutput$outboundSchema,
      CodeInterpreterOutput$outboundSchema,
      FileSearchOutput$outboundSchema,
      ResponseOutputMessage$outboundSchema,
    ]),
  ),
  outputParsed: z.nullable(FinalAnswer$outboundSchema).optional(),
  tools: z.array(Tool$outboundSchema),
  reasoning: Reasoning$outboundSchema,
  parallelToolCalls: z.boolean().default(false),
  store: z.boolean().default(false),
  temperature: z.number().default(1),
  previousResponseId: z.nullable(z.string()).optional(),
  toolChoice: z.literal("auto").default("auto" as const),
  topP: z.number().default(1),
  truncation: z.literal("disabled").default("disabled" as const),
  usage: RagieApiSchemaResponseUsage$outboundSchema,
  user: z.nullable(z.any()).optional(),
  metadata: z.record(z.any()).optional(),
}).transform((v) => {
  return remap$(v, {
    createdAt: "created_at",
    incompleteDetails: "incomplete_details",
    maxOutputTokens: "max_output_tokens",
    outputParsed: "output_parsed",
    parallelToolCalls: "parallel_tool_calls",
    previousResponseId: "previous_response_id",
    toolChoice: "tool_choice",
    topP: "top_p",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ResponseT$ {
  /** @deprecated use `ResponseT$inboundSchema` instead. */
  export const inboundSchema = ResponseT$inboundSchema;
  /** @deprecated use `ResponseT$outboundSchema` instead. */
  export const outboundSchema = ResponseT$outboundSchema;
  /** @deprecated use `ResponseT$Outbound` instead. */
  export type Outbound = ResponseT$Outbound;
}

export function responseToJSON(responseT: ResponseT): string {
  return JSON.stringify(ResponseT$outboundSchema.parse(responseT));
}

export function responseFromJSON(
  jsonString: string,
): SafeParseResult<ResponseT, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ResponseT$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ResponseT' from JSON`,
  );
}
