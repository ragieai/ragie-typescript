/*
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

import { remap as remap$ } from "../../lib/primitives.js";
import { ClosedEnum } from "../../types/enums.js";
import * as z from "zod";

/**
 * The scope of the instruction. Determines whether the instruction is applied to the entire document or to each chunk of the document. Options are `'document'` or `'chunk'`. Generally `'document'` should be used when analyzing the full document is desired, such as when generating a summary or determining sentiment, and `'chunk'` should be used when a fine grained search over a document is desired.
 */
export const InstructionUpdateResponseScope = {
    Document: "document",
    Chunk: "chunk",
} as const;
/**
 * The scope of the instruction. Determines whether the instruction is applied to the entire document or to each chunk of the document. Options are `'document'` or `'chunk'`. Generally `'document'` should be used when analyzing the full document is desired, such as when generating a summary or determining sentiment, and `'chunk'` should be used when a fine grained search over a document is desired.
 */
export type InstructionUpdateResponseScope = ClosedEnum<typeof InstructionUpdateResponseScope>;

/**
 * The JSON schema definition of the entity generated by an instruction. The schema must define an `object` at its root. If the instruction is expected to generate multiple items, the root object should have a key which defines an array of the expected items. An instruction which generates multiple emails may be expressed as `{"type": "object", "properties": {"emails": { "type": "array", "items": { "type": "string"}}}}`. Simple values may be expressed as an object with a single key. For example, a summary instruction may generate a single string value. The schema might be `{"type": "object", "properties": { "summary": { "type": "string"}}}`.
 */
export type InstructionUpdateResponseEntitySchema = {};

export type InstructionUpdateResponse = {
    id: string;
    createdAt: Date;
    updatedAt: Date;
    /**
     * The name of the instruction. Must be unique.
     */
    name: string;
    /**
     * Whether the instruction is active. Active instructions are applied to documents when they're created or when their file is updated.
     */
    active?: boolean | undefined;
    /**
     * The scope of the instruction. Determines whether the instruction is applied to the entire document or to each chunk of the document. Options are `'document'` or `'chunk'`. Generally `'document'` should be used when analyzing the full document is desired, such as when generating a summary or determining sentiment, and `'chunk'` should be used when a fine grained search over a document is desired.
     */
    scope?: InstructionUpdateResponseScope | undefined;
    /**
     * A natural language instruction which will be applied to documents as they are created and updated. The results of the `instruction_prompt` will be stored as an `entity` in the schema defined by the `entity_schema` parameter.
     */
    prompt: string;
    /**
     * The JSON schema definition of the entity generated by an instruction. The schema must define an `object` at its root. If the instruction is expected to generate multiple items, the root object should have a key which defines an array of the expected items. An instruction which generates multiple emails may be expressed as `{"type": "object", "properties": {"emails": { "type": "array", "items": { "type": "string"}}}}`. Simple values may be expressed as an object with a single key. For example, a summary instruction may generate a single string value. The schema might be `{"type": "object", "properties": { "summary": { "type": "string"}}}`.
     */
    entitySchema: InstructionUpdateResponseEntitySchema;
};

/** @internal */
export const InstructionUpdateResponseScope$inboundSchema: z.ZodNativeEnum<
    typeof InstructionUpdateResponseScope
> = z.nativeEnum(InstructionUpdateResponseScope);

/** @internal */
export const InstructionUpdateResponseScope$outboundSchema: z.ZodNativeEnum<
    typeof InstructionUpdateResponseScope
> = InstructionUpdateResponseScope$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InstructionUpdateResponseScope$ {
    /** @deprecated use `InstructionUpdateResponseScope$inboundSchema` instead. */
    export const inboundSchema = InstructionUpdateResponseScope$inboundSchema;
    /** @deprecated use `InstructionUpdateResponseScope$outboundSchema` instead. */
    export const outboundSchema = InstructionUpdateResponseScope$outboundSchema;
}

/** @internal */
export const InstructionUpdateResponseEntitySchema$inboundSchema: z.ZodType<
    InstructionUpdateResponseEntitySchema,
    z.ZodTypeDef,
    unknown
> = z.object({});

/** @internal */
export type InstructionUpdateResponseEntitySchema$Outbound = {};

/** @internal */
export const InstructionUpdateResponseEntitySchema$outboundSchema: z.ZodType<
    InstructionUpdateResponseEntitySchema$Outbound,
    z.ZodTypeDef,
    InstructionUpdateResponseEntitySchema
> = z.object({});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InstructionUpdateResponseEntitySchema$ {
    /** @deprecated use `InstructionUpdateResponseEntitySchema$inboundSchema` instead. */
    export const inboundSchema = InstructionUpdateResponseEntitySchema$inboundSchema;
    /** @deprecated use `InstructionUpdateResponseEntitySchema$outboundSchema` instead. */
    export const outboundSchema = InstructionUpdateResponseEntitySchema$outboundSchema;
    /** @deprecated use `InstructionUpdateResponseEntitySchema$Outbound` instead. */
    export type Outbound = InstructionUpdateResponseEntitySchema$Outbound;
}

/** @internal */
export const InstructionUpdateResponse$inboundSchema: z.ZodType<
    InstructionUpdateResponse,
    z.ZodTypeDef,
    unknown
> = z
    .object({
        id: z.string(),
        created_at: z
            .string()
            .datetime({ offset: true })
            .transform((v) => new Date(v)),
        updated_at: z
            .string()
            .datetime({ offset: true })
            .transform((v) => new Date(v)),
        name: z.string(),
        active: z.boolean().default(true),
        scope: InstructionUpdateResponseScope$inboundSchema.default("chunk"),
        prompt: z.string(),
        entity_schema: z.lazy(() => InstructionUpdateResponseEntitySchema$inboundSchema),
    })
    .transform((v) => {
        return remap$(v, {
            created_at: "createdAt",
            updated_at: "updatedAt",
            entity_schema: "entitySchema",
        });
    });

/** @internal */
export type InstructionUpdateResponse$Outbound = {
    id: string;
    created_at: string;
    updated_at: string;
    name: string;
    active: boolean;
    scope: string;
    prompt: string;
    entity_schema: InstructionUpdateResponseEntitySchema$Outbound;
};

/** @internal */
export const InstructionUpdateResponse$outboundSchema: z.ZodType<
    InstructionUpdateResponse$Outbound,
    z.ZodTypeDef,
    InstructionUpdateResponse
> = z
    .object({
        id: z.string(),
        createdAt: z.date().transform((v) => v.toISOString()),
        updatedAt: z.date().transform((v) => v.toISOString()),
        name: z.string(),
        active: z.boolean().default(true),
        scope: InstructionUpdateResponseScope$outboundSchema.default("chunk"),
        prompt: z.string(),
        entitySchema: z.lazy(() => InstructionUpdateResponseEntitySchema$outboundSchema),
    })
    .transform((v) => {
        return remap$(v, {
            createdAt: "created_at",
            updatedAt: "updated_at",
            entitySchema: "entity_schema",
        });
    });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InstructionUpdateResponse$ {
    /** @deprecated use `InstructionUpdateResponse$inboundSchema` instead. */
    export const inboundSchema = InstructionUpdateResponse$inboundSchema;
    /** @deprecated use `InstructionUpdateResponse$outboundSchema` instead. */
    export const outboundSchema = InstructionUpdateResponse$outboundSchema;
    /** @deprecated use `InstructionUpdateResponse$Outbound` instead. */
    export type Outbound = InstructionUpdateResponse$Outbound;
}
