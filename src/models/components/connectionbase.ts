/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import { ClosedEnum } from "../../types/enums.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";
import {
  MediaModeParam,
  MediaModeParam$inboundSchema,
  MediaModeParam$Outbound,
  MediaModeParam$outboundSchema,
} from "./mediamodeparam.js";

export const PartitionStrategy1 = {
  HiRes: "hi_res",
  Fast: "fast",
} as const;
export type PartitionStrategy1 = ClosedEnum<typeof PartitionStrategy1>;

export type PartitionStrategy = MediaModeParam | PartitionStrategy1;

export type ConnectionBaseMetadata = string | number | boolean | Array<string>;

export type ConnectionBase = {
  partitionStrategy: MediaModeParam | PartitionStrategy1;
  /**
   * Metadata for the document. Keys must be strings. Values may be strings, numbers, booleans, or lists of strings. Numbers may be integers or floating point and will be converted to 64 bit floating point. 1000 total values are allowed. Each item in an array counts towards the total. The following keys are reserved for internal use: `document_id`, `document_type`, `document_source`, `document_name`, `document_uploaded_at`, `start_time`, `end_time`.
   */
  metadata?:
    | { [k: string]: string | number | boolean | Array<string> }
    | undefined;
  /**
   * The maximum number of pages a connection will sync. The connection will be disabled after this limit is reached. Some in process documents may continue processing. Remove the limit by setting to `null`.
   */
  pageLimit?: number | null | undefined;
};

/** @internal */
export const PartitionStrategy1$inboundSchema: z.ZodNativeEnum<
  typeof PartitionStrategy1
> = z.nativeEnum(PartitionStrategy1);

/** @internal */
export const PartitionStrategy1$outboundSchema: z.ZodNativeEnum<
  typeof PartitionStrategy1
> = PartitionStrategy1$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PartitionStrategy1$ {
  /** @deprecated use `PartitionStrategy1$inboundSchema` instead. */
  export const inboundSchema = PartitionStrategy1$inboundSchema;
  /** @deprecated use `PartitionStrategy1$outboundSchema` instead. */
  export const outboundSchema = PartitionStrategy1$outboundSchema;
}

/** @internal */
export const PartitionStrategy$inboundSchema: z.ZodType<
  PartitionStrategy,
  z.ZodTypeDef,
  unknown
> = z.union([MediaModeParam$inboundSchema, PartitionStrategy1$inboundSchema]);

/** @internal */
export type PartitionStrategy$Outbound = MediaModeParam$Outbound | string;

/** @internal */
export const PartitionStrategy$outboundSchema: z.ZodType<
  PartitionStrategy$Outbound,
  z.ZodTypeDef,
  PartitionStrategy
> = z.union([MediaModeParam$outboundSchema, PartitionStrategy1$outboundSchema]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PartitionStrategy$ {
  /** @deprecated use `PartitionStrategy$inboundSchema` instead. */
  export const inboundSchema = PartitionStrategy$inboundSchema;
  /** @deprecated use `PartitionStrategy$outboundSchema` instead. */
  export const outboundSchema = PartitionStrategy$outboundSchema;
  /** @deprecated use `PartitionStrategy$Outbound` instead. */
  export type Outbound = PartitionStrategy$Outbound;
}

export function partitionStrategyToJSON(
  partitionStrategy: PartitionStrategy,
): string {
  return JSON.stringify(
    PartitionStrategy$outboundSchema.parse(partitionStrategy),
  );
}

export function partitionStrategyFromJSON(
  jsonString: string,
): SafeParseResult<PartitionStrategy, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PartitionStrategy$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PartitionStrategy' from JSON`,
  );
}

/** @internal */
export const ConnectionBaseMetadata$inboundSchema: z.ZodType<
  ConnectionBaseMetadata,
  z.ZodTypeDef,
  unknown
> = z.union([z.string(), z.number().int(), z.boolean(), z.array(z.string())]);

/** @internal */
export type ConnectionBaseMetadata$Outbound =
  | string
  | number
  | boolean
  | Array<string>;

/** @internal */
export const ConnectionBaseMetadata$outboundSchema: z.ZodType<
  ConnectionBaseMetadata$Outbound,
  z.ZodTypeDef,
  ConnectionBaseMetadata
> = z.union([z.string(), z.number().int(), z.boolean(), z.array(z.string())]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ConnectionBaseMetadata$ {
  /** @deprecated use `ConnectionBaseMetadata$inboundSchema` instead. */
  export const inboundSchema = ConnectionBaseMetadata$inboundSchema;
  /** @deprecated use `ConnectionBaseMetadata$outboundSchema` instead. */
  export const outboundSchema = ConnectionBaseMetadata$outboundSchema;
  /** @deprecated use `ConnectionBaseMetadata$Outbound` instead. */
  export type Outbound = ConnectionBaseMetadata$Outbound;
}

export function connectionBaseMetadataToJSON(
  connectionBaseMetadata: ConnectionBaseMetadata,
): string {
  return JSON.stringify(
    ConnectionBaseMetadata$outboundSchema.parse(connectionBaseMetadata),
  );
}

export function connectionBaseMetadataFromJSON(
  jsonString: string,
): SafeParseResult<ConnectionBaseMetadata, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ConnectionBaseMetadata$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ConnectionBaseMetadata' from JSON`,
  );
}

/** @internal */
export const ConnectionBase$inboundSchema: z.ZodType<
  ConnectionBase,
  z.ZodTypeDef,
  unknown
> = z.object({
  partition_strategy: z.union([
    MediaModeParam$inboundSchema,
    PartitionStrategy1$inboundSchema,
  ]),
  metadata: z.record(
    z.union([z.string(), z.number().int(), z.boolean(), z.array(z.string())]),
  ).optional(),
  page_limit: z.nullable(z.number().int()).optional(),
}).transform((v) => {
  return remap$(v, {
    "partition_strategy": "partitionStrategy",
    "page_limit": "pageLimit",
  });
});

/** @internal */
export type ConnectionBase$Outbound = {
  partition_strategy: MediaModeParam$Outbound | string;
  metadata?:
    | { [k: string]: string | number | boolean | Array<string> }
    | undefined;
  page_limit?: number | null | undefined;
};

/** @internal */
export const ConnectionBase$outboundSchema: z.ZodType<
  ConnectionBase$Outbound,
  z.ZodTypeDef,
  ConnectionBase
> = z.object({
  partitionStrategy: z.union([
    MediaModeParam$outboundSchema,
    PartitionStrategy1$outboundSchema,
  ]),
  metadata: z.record(
    z.union([z.string(), z.number().int(), z.boolean(), z.array(z.string())]),
  ).optional(),
  pageLimit: z.nullable(z.number().int()).optional(),
}).transform((v) => {
  return remap$(v, {
    partitionStrategy: "partition_strategy",
    pageLimit: "page_limit",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ConnectionBase$ {
  /** @deprecated use `ConnectionBase$inboundSchema` instead. */
  export const inboundSchema = ConnectionBase$inboundSchema;
  /** @deprecated use `ConnectionBase$outboundSchema` instead. */
  export const outboundSchema = ConnectionBase$outboundSchema;
  /** @deprecated use `ConnectionBase$Outbound` instead. */
  export type Outbound = ConnectionBase$Outbound;
}

export function connectionBaseToJSON(connectionBase: ConnectionBase): string {
  return JSON.stringify(ConnectionBase$outboundSchema.parse(connectionBase));
}

export function connectionBaseFromJSON(
  jsonString: string,
): SafeParseResult<ConnectionBase, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ConnectionBase$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ConnectionBase' from JSON`,
  );
}
