/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import { documentsCreate } from "../funcs/documentsCreate.js";
import { documentsCreateDocumentFromUrl } from "../funcs/documentsCreateDocumentFromUrl.js";
import { documentsCreateRaw } from "../funcs/documentsCreateRaw.js";
import { documentsDelete } from "../funcs/documentsDelete.js";
import { documentsGet } from "../funcs/documentsGet.js";
import { documentsGetChunk } from "../funcs/documentsGetChunk.js";
import { documentsGetChunkContent } from "../funcs/documentsGetChunkContent.js";
import { documentsGetChunks } from "../funcs/documentsGetChunks.js";
import { documentsGetContent } from "../funcs/documentsGetContent.js";
import { documentsGetSource } from "../funcs/documentsGetSource.js";
import { documentsGetSummary } from "../funcs/documentsGetSummary.js";
import { documentsList } from "../funcs/documentsList.js";
import { documentsPatchMetadata } from "../funcs/documentsPatchMetadata.js";
import { documentsUpdateDocumentFromUrl } from "../funcs/documentsUpdateDocumentFromUrl.js";
import { documentsUpdateFile } from "../funcs/documentsUpdateFile.js";
import { documentsUpdateRaw } from "../funcs/documentsUpdateRaw.js";
import { ClientSDK, RequestOptions } from "../lib/sdks.js";
import * as components from "../models/components/index.js";
import * as operations from "../models/operations/index.js";
import { unwrapAsync } from "../types/fp.js";
import { PageIterator, unwrapResultIterator } from "../types/operations.js";

export class Documents extends ClientSDK {
  /**
   * List Documents
   *
   * @remarks
   * List all documents sorted by created_at in descending order. Results are paginated with a max limit of 100. When more documents are available, a `cursor` will be provided. Use the `cursor` parameter to retrieve the subsequent page.
   */
  async list(
    request?: operations.ListDocumentsRequest | undefined,
    options?: RequestOptions,
  ): Promise<
    PageIterator<operations.ListDocumentsResponse, { cursor: string }>
  > {
    return unwrapResultIterator(documentsList(
      this,
      request,
      options,
    ));
  }

  /**
   * Create Document
   *
   * @remarks
   * On ingest, the document goes through a series of steps before it is ready for retrieval. Each step is reflected in the status of the document which can be one of [`pending`, `partitioning`, `partitioned`, `refined`, `chunked`, `indexed`, `summary_indexed`, `keyword_indexed`, `ready`, `failed`]. The document is available for retrieval once it is in ready state. The summary index step can take a few seconds. You can optionally use the document for retrieval once it is in `indexed` state. However the summary will only be available once the state has changed to `summary_indexed` or `ready`.
   */
  async create(
    request: components.CreateDocumentParams,
    options?: RequestOptions,
  ): Promise<components.Document> {
    return unwrapAsync(documentsCreate(
      this,
      request,
      options,
    ));
  }

  /**
   * Create Document Raw
   *
   * @remarks
   * Ingest a document as raw text. On ingest, the document goes through a series of steps before it is ready for retrieval. Each step is reflected in the status of the document which can be one of [`pending`, `partitioning`, `partitioned`, `refined`, `chunked`, `indexed`, `summary_indexed`, `keyword_indexed`, `ready`, `failed`]. The document is available for retrieval once it is in ready state. The summary index step can take a few seconds. You can optionally use the document for retrieval once it is in `indexed` state. However the summary will only be available once the state has changed to `summary_indexed` or `ready`.
   */
  async createRaw(
    request: components.CreateDocumentRawParams,
    options?: RequestOptions,
  ): Promise<components.Document> {
    return unwrapAsync(documentsCreateRaw(
      this,
      request,
      options,
    ));
  }

  /**
   * Create Document From Url
   *
   * @remarks
   * Ingest a document from a publicly accessible URL. On ingest, the document goes through a series of steps before it is ready for retrieval. Each step is reflected in the status of the document which can be one of [`pending`, `partitioning`, `partitioned`, `refined`, `chunked`, `indexed`, `summary_indexed`, `keyword_indexed`, `ready`, `failed`]. The document is available for retrieval once it is in ready state. The summary index step can take a few seconds. You can optionally use the document for retrieval once it is in `indexed` state. However the summary will only be available once the state has changed to `summary_indexed` or `ready`. PDF files over 2000 pages are not supported in hi_res mode.
   */
  async createDocumentFromUrl(
    request: components.CreateDocumentFromUrlParams,
    options?: RequestOptions,
  ): Promise<components.Document> {
    return unwrapAsync(documentsCreateDocumentFromUrl(
      this,
      request,
      options,
    ));
  }

  /**
   * Get Document
   */
  async get(
    request: operations.GetDocumentRequest,
    options?: RequestOptions,
  ): Promise<components.DocumentGet> {
    return unwrapAsync(documentsGet(
      this,
      request,
      options,
    ));
  }

  /**
   * Delete Document
   */
  async delete(
    request: operations.DeleteDocumentRequest,
    options?: RequestOptions,
  ): Promise<components.DocumentDelete> {
    return unwrapAsync(documentsDelete(
      this,
      request,
      options,
    ));
  }

  /**
   * Update Document File
   */
  async updateFile(
    request: operations.UpdateDocumentFileRequest,
    options?: RequestOptions,
  ): Promise<components.DocumentFileUpdate> {
    return unwrapAsync(documentsUpdateFile(
      this,
      request,
      options,
    ));
  }

  /**
   * Update Document Raw
   */
  async updateRaw(
    request: operations.UpdateDocumentRawRequest,
    options?: RequestOptions,
  ): Promise<components.DocumentRawUpdate> {
    return unwrapAsync(documentsUpdateRaw(
      this,
      request,
      options,
    ));
  }

  /**
   * Update Document Url
   *
   * @remarks
   * Updates a document from a publicly accessible URL. On ingest, the document goes through a series of steps before it is ready for retrieval. Each step is reflected in the status of the document which can be one of [`pending`, `partitioning`, `partitioned`, `refined`, `chunked`, `indexed`, `summary_indexed`, `keyword_indexed`, `ready`, `failed`]. The document is available for retrieval once it is in ready state. The summary index step can take a few seconds. You can optionally use the document for retrieval once it is in `indexed` state. However the summary will only be available once the state has changed to `summary_indexed` or `ready`. PDF files over 2000 pages are not supported in hi_res mode.
   */
  async updateDocumentFromUrl(
    request: operations.UpdateDocumentFromUrlRequest,
    options?: RequestOptions,
  ): Promise<components.DocumentUrlUpdate> {
    return unwrapAsync(documentsUpdateDocumentFromUrl(
      this,
      request,
      options,
    ));
  }

  /**
   * Patch Document Metadata
   */
  async patchMetadata(
    request: operations.PatchDocumentMetadataRequest,
    options?: RequestOptions,
  ): Promise<operations.PatchDocumentMetadataResponsePatchdocumentmetadata> {
    return unwrapAsync(documentsPatchMetadata(
      this,
      request,
      options,
    ));
  }

  /**
   * Get Document Chunks
   *
   * @remarks
   * List all document chunks sorted by index in ascending order. May be limited to a range of chunk indices with the `start_index` and `end_index` parameters. Documents created prior to 9/18/2024, which have not been updated since, have chunks which do not include an index and their index will be returned as -1. They will be sorted by their ID instead. Updating the document using the `Update Document File` or `Update Document Raw` endpoint will regenerate document chunks, including their index. Results are paginated with a max limit of 100. When more chunks are available, a `cursor` will be provided. Use the `cursor` parameter to retrieve the subsequent page.
   */
  async getChunks(
    request: operations.GetDocumentChunksRequest,
    options?: RequestOptions,
  ): Promise<components.DocumentChunkList> {
    return unwrapAsync(documentsGetChunks(
      this,
      request,
      options,
    ));
  }

  /**
   * Get Document Chunk
   *
   * @remarks
   * Gets a document chunk by its document and chunk ID.
   */
  async getChunk(
    request: operations.GetDocumentChunkRequest,
    options?: RequestOptions,
  ): Promise<components.DocumentChunkDetail> {
    return unwrapAsync(documentsGetChunk(
      this,
      request,
      options,
    ));
  }

  /**
   * Get Document Chunk Content
   *
   * @remarks
   * Returns the content of a document chunk in the requested format. Can be used to stream media of the content for audio/video documents.
   */
  async getChunkContent(
    request: operations.GetDocumentChunkContentRequest,
    options?: RequestOptions,
  ): Promise<any> {
    return unwrapAsync(documentsGetChunkContent(
      this,
      request,
      options,
    ));
  }

  /**
   * Get Document Content
   *
   * @remarks
   * Get the content of a document. The `media_type` parameter can be used to request the content in a different format. When requesting as `application/json` additional metadata about the document will be included. If the original document contained content such as images or other non-textual media, this response will include a text description of that media instead of the original file data. Using mime types such as `audio/mpeg` or `video/mp4` will stream the file in a format that can be provided to an audio video player.
   */
  async getContent(
    request: operations.GetDocumentContentRequest,
    options?: RequestOptions,
  ): Promise<components.DocumentWithContent> {
    return unwrapAsync(documentsGetContent(
      this,
      request,
      options,
    ));
  }

  /**
   * Get Document Source
   *
   * @remarks
   * Get the source file of a document. The source file is the original file that was uploaded to create the document. If the document was created from a URL, the source file will be the content of the URL. If the document was created by a connection, the source file will vary based on the type of the connection. For example, a Google Drive connection will return the file that was synced from the Google Drive, while a SalesForce connection would return a JSON file of the data synced from SalesForce.
   */
  async getSource(
    request: operations.GetDocumentSourceRequest,
    options?: RequestOptions,
  ): Promise<ReadableStream<Uint8Array>> {
    return unwrapAsync(documentsGetSource(
      this,
      request,
      options,
    ));
  }

  /**
   * Get Document Summary
   *
   * @remarks
   * Get a LLM generated summary of the document. The summary is created when the document is first created or updated. Documents of types ['xls', 'xlsx', 'csv', 'json'] are not supported for summarization. Documents greater than 1M in token length are not supported. This feature is in beta and may change in the future.
   */
  async getSummary(
    request: operations.GetDocumentSummaryRequest,
    options?: RequestOptions,
  ): Promise<components.DocumentSummary> {
    return unwrapAsync(documentsGetSummary(
      this,
      request,
      options,
    ));
  }
}
